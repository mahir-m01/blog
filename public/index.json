
[{"content":"Hello there! Curious to know more about me?\nYou can here ‚Üí\n","date":"20 October 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"20 October 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"20 October 2025","externalUrl":null,"permalink":"/tags/tryhackme/","section":"Tags","summary":"","title":"TryHackMe","type":"tags"},{"content":"","date":"20 October 2025","externalUrl":null,"permalink":"/tags/wireshark/","section":"Tags","summary":"","title":"Wireshark","type":"tags"},{"content":"Note: The questions are shortened for a cleaner view\nTask 1 - Introduction # The answers are already provided by THM.\nFile is used to simulate the screenshots? # Ans: http1.pcapng\nFile is used to answer the questions? # Ans: Exercise.pcapng\nTask 2 - Tool Overview # What is the flag? # Ans: TryHackMe_Wireshark_Demo\nTotal number of packets? # Ans: 58620\nSHA256 hash value ? # Ans: f446de335565fb0b0ee5e5a3266703c778b2f3dfad7efeaeccb2da5641a6d6eb\nTask 3 - Packet Dissection # Markup Language used? # Ans: eXtensible Markup Language\nArrival date of the packet? # (Answer format: Month/Day/Year)\nAns: 05/13/2004\nTTL value? # Ans: 47\nTCP payload size? # Ans: 424\ne-tag value? # Ans: 9a01a-4696-7e354b00\nThe HTTP ETag (entity tag) is an identifier for a specific version of a resource, used for caching efficiency and avoiding mid-air collisions.\nTask 4 - Packet Navigation # Name of artist 1? # Ans: r4w8173\nGo to packet 12. What is the answer? # Ans: 911cd574a42865a956ccde2d04495ebf\nAlien\u0026rsquo;s name? # Ans: PACKETMASTER\nNumber of warnings? # Ans: 1636\nTask 5 - Packet Filtering # Filter query? # Ans: http\nNumber of displayed packets? # Ans: 1089\nTotal number of artists? # \u0026lt;div id=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#39;story\u0026#39;\u0026gt; \u0026lt;a href=\u0026#39;artists.php?artist=1\u0026#39;\u0026gt;\u0026lt;h3\u0026gt;r4w8173\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#39;#\u0026#39; onClick=\u0026#34;window.open(\u0026#39;./comment.php?aid=1\u0026#39;,\u0026#39;comment\u0026#39;,\u0026#39;width=500,height=400\u0026#39;)\u0026#34;\u0026gt;comment on this artist\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;story\u0026#39;\u0026gt; \u0026lt;a href=\u0026#39;artists.php?artist=2\u0026#39;\u0026gt;\u0026lt;h3\u0026gt;Blad3\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#39;#\u0026#39; onClick=\u0026#34;window.open(\u0026#39;./comment.php?aid=2\u0026#39;,\u0026#39;comment\u0026#39;,\u0026#39;width=500,height=400\u0026#39;)\u0026#34;\u0026gt;comment on this artist\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;story\u0026#39;\u0026gt; \u0026lt;a href=\u0026#39;artists.php?artist=3\u0026#39;\u0026gt;\u0026lt;h3\u0026gt;lyzae\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#39;#\u0026#39; onClick=\u0026#34;window.open(\u0026#39;./comment.php?aid=3\u0026#39;,\u0026#39;comment\u0026#39;,\u0026#39;width=500,height=400\u0026#39;)\u0026#34;\u0026gt;comment on this artist\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;\t\u0026lt;/div\u0026gt; From the above code block that we get by searching for the term artist we get:\nAns: 3\nName of the second artist? # Ans: Blad3\n","date":"20 October 2025","externalUrl":null,"permalink":"/writeups/wireshark-the-basics/","section":"Writeups","summary":"","title":"Wireshark: The Basics","type":"writeups"},{"content":" Writeups and walkthroughs for rooms, CTFs and other challenges from TryHackMe. ","date":"20 October 2025","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":" Notes, hacks, and half - broken experiments around tech and security. Stuff I‚Äôm learning, exploring, breaking, or fixing. My corner of the web where I dump thoughts on code, security, and the weird tech rabbit holes I end up in.\n","date":"29 September 2025","externalUrl":null,"permalink":"/posts/","section":"Blogs","summary":"","title":"Blogs","type":"posts"},{"content":"","date":"29 September 2025","externalUrl":null,"permalink":"/tags/cryptograpahy/","section":"Tags","summary":"","title":"Cryptograpahy","type":"tags"},{"content":"","date":"29 September 2025","externalUrl":null,"permalink":"/tags/ecc/","section":"Tags","summary":"","title":"ECC","type":"tags"},{"content":"I was reviewing a CTF that my friend shared with me and I came across a question about \u0026lsquo;Elliptical Curve Cryptography\u0026rsquo;. I haven\u0026rsquo;t yet explored the deeper waters of cryptography and this one was pretty new to me. But hey, thats the essence of CTFs and I always appreciate a CTF that encourages you to explore and research instead of expecting you to know everything to be able to solve the question it offers. And during my research, I came across an amazing github repo article that explains Elliptical Curve Cryptography beautifully. My colleagues are sick and tired of hearing me say this but it is one of the best explanations to any topic I\u0026rsquo;ve encountered thus far.\nThe Challenge # The challenge provided 2 files and absolutely no context. So I had to go into this pretty much blind.\nECC.py # from secrets import a, b from collections import namedtuple from Crypto.Util.number import inverse, bytes_to_long FLAG = b\u0026#34;\u0026lt;REDACTED\u0026gt;\u0026#34; coordinate = namedtuple(\u0026#34;coordinate\u0026#34;, \u0026#34;x y\u0026#34;) o = \u0026#39;inf\u0026#39; def check(P): if P == o: return True else: return (P.y**2 - (P.x**3 + a*P.x + b)) % p == 0 and 0 \u0026lt;= P.x \u0026lt; p and 0 \u0026lt;= P.y \u0026lt; p def pinverse(P): if P == o: return P return coordinate(P.x, -P.y % p) def addition(P, Q): if P == o: return Q elif Q == o: return P elif Q == pinverse(P): return o else: if P == Q: l = (3*P.x**2 + a)*inverse(2*P.y, p) l%= p else: l= (Q.y - P.y) * inverse((Q.x - P.x), p) l%= p Sx = (l**2 - P.x - Q.x) % p Sy = (l*(P.x - Sx) - P.y) % p S = coordinate(Sx, Sy) assert check(S) return S def dbl(P, n): Q = P S = o while n \u0026gt; 0: if n % 2 == 1: S = addition(S, Q) Q = addition(Q, Q) n = n // 2 assert check(S) return S def public_key(): d = bytes_to_long(FLAG) return dbl(G, d) p=8027944432202837970016382166567613248055695684315346001687786051508079095211 # a and b are hidden :( gx =2105875689926932895143196884562047110500169848659102540268132432000998177662 gy = 229423364975599771276867046437732535419264207423006298355584008095715972502 G = coordinate(gx, gy) Q = public_key() print(Q) Output.txt # coordinate(x=3685899851710902647676109902198159056110437731756939136804788198715504103708, y=259383739652175557073121224113233231149464856533427701609450332409012223263) Analysis \u0026amp; Solution # 1) Compute the Curve Parameters # The first step is to compute the value of a and b before we can analyse further. The values a and b are the curve parameters that define the specific elliptic curve.\nfrom Crypto.Util.number import inverse p = 8027944432202837970016382166567613248055695684315346001687786051508079095211 Gx = 2105875689926932895143196884562047110500169848659102540268132432000998177662 Gy = 229423364975599771276867046437732535419264207423006298355584008095715972502 Qx = 3685899851710902647676109902198159056110437731756939136804788198715504103708 Qy = 259383739652175557073121224113233231149464856533427701609450332409012223263 # Compute curve parameters a and b # The elliptic curve equation is: y^2 = x^3 + a*x + b (mod p) # We have two points (G and Q) on the curve, so we can solve for a and b # Step 1: compute numerator and denominator to solve for \u0026#39;a\u0026#39; # Derived from: gy^2 - qy^2 = (gx^3 + a*gx + b) - (qx^3 + a*qx + b) mod p num = (pow(gy, 2, p) - pow(qy, 2, p) - (pow(gx, 3, p) - pow(qx, 3, p))) % p den = (gx - qx) % p # Step 2: compute \u0026#39;a\u0026#39; using modular inverse a = (num * inverse(den, p)) % p # Step 3: compute \u0026#39;b\u0026#39; using one of the points (G) b = (pow(gy, 2, p) - pow(gx, 3, p) - (a * gx)) % p print(\u0026#34;Computed curve parameters:\u0026#34;) print(\u0026#34;a =\u0026#34;, a) print(\u0026#34;b =\u0026#34;, b) 2) Verify Singularity # Now that we have all the required information (to an extent), primarily a and b , in my opinion its best practice to test whether the curve is singular or elliptical. Depending on the result our exploit paths will differ significantly.\nA non-singular curve is a curve whose certain value, called the \u0026ldquo;discriminant\u0026rdquo; of the curve, is nonzero. It holds when its parameters¬†ùëé¬†and¬†ùëè¬†satisfy the inequality:\n\\(4a^3 + 27b^2 \\not = 0\\)\nA curve that does not satisfy this inequality has a \u0026ldquo;problematic\u0026rdquo; point called a¬†singular point. There are two types of such points: node and cusp\nWhat this means:\nThe curve has a cusp or a node (self-intersection) instead of being smooth.\nBecause of this, the set of points on the curve does not form a proper group under standard elliptic curve addition.\nThe curve does happen to be singular and is therefore vulnerable 3) Exploiting the Vulnerability # The following code from the github article exploits Elliptical Curves that are singular:\np = 8027944432202837970016382166567613248055695684315346001687786051508079095211 a = 57276030533159328146887045530181492991804891249085933575331289605 b = 4890108522805667613288743457538583820154692228816052112017335705944231712111 assert (4*a^3 + 27*b^2) % p == 0 Gx = 2105875689926932895143196884562047110500169848659102540268132432000998177662 Gy = 229423364975599771276867046437732535419264207423006298355584008095715972502 Qx = 3685899851710902647676109902198159056110437731756939136804788198715504103708 Qy = 259383739652175557073121224113233231149464856533427701609450332409012223263 x = GF(p)[\u0026#34;x\u0026#34;].gen() f = x^3 + a*x + b roots = f.roots() assert len(roots) == 2 # two roots, so one must be double if roots[0][1] == 2: double_root = roots[0][0] single_root = roots[1][0] else: double_root = roots[1][0] single_root = roots[0][0] print(\u0026#34;double root:\u0026#34;, double_root) print(\u0026#34;single root:\u0026#34;, single_root) # map G and Q to the new \u0026#34;shifted\u0026#34; curve Gx = (Gx - double_root) Qx = (Qx - double_root) # Transform G and Q into numbers g and q, such that q=g^n t = double_root - single_root t_sqrt = t.square_root() def transform(x, y, t_sqrt): return (y + t_sqrt * x) / (y - t_sqrt * x) g = transform(Gx, Gy, t_sqrt) q = transform(Qx, Qy, t_sqrt) print(\u0026#34;g:\u0026#34;, g) print(\u0026#34;q:\u0026#34;, q) # Find the private key n print(\u0026#34;Factors of p-1:\u0026#34;, factor(p-1)) print(\u0026#34;Calculating discrete log for g and q...\u0026#34;) found_key = discrete_log(q, g) print(\u0026#34;Found private key:\u0026#34;, found_key) from Crypto.Util.number import long_to_bytes print(\u0026#34;The secret is:\u0026#34;, long_to_bytes(found_key).decode()) When I first tried it worked almost \u0026rsquo;too-well\u0026rsquo;. I wonder if the creator took an inspiration from the same article to create the question. Nevertheless, it was fun to solve.\nConclusion # Obviously I did not get into the depths of Elliptical Curve Cryptography here, you can check out the github article for that. This was more of a documentation for one of the questions I encountered. Its about time I get well versed with ECC now\u0026hellip;\n","date":"29 September 2025","externalUrl":null,"permalink":"/posts/elliptical-curve-cryptography/","section":"Blogs","summary":"","title":"ECC CTFs are Interesting","type":"posts"},{"content":" Hi, I‚Äôm Mahir. I‚Äôm majoring in Computer Science \u0026amp; Artificial Intelligence with a minor in Psychology, but my story with tech started way before college.\nBack during COVID, when the world slowed down, I found myself diving into the rabbit hole of networking and cybersecurity and I never really climbed out. Since then, I‚Äôve been building home labs, tinkering with servers, and playing around with remote networks. It‚Äôs just in my nature to break things apart, see what makes them tick, and learn by putting them back together (sometimes in better shape, sometimes‚Ä¶ not so much). That curiosity is what sparked my obsession with tech and IT, and it keeps me hooked.\nI currently head the Cybersecurity Club at my university, where I get to share that curiosity with others, swap ideas, and geek out over challenges. I also hold ISC2‚Äôs Certified in Cybersecurity (CC) albeit a beginner cert, it is just the first step, but one that keeps me motivated to aim higher with certifications like CCNA and SSCP down the line.\nAt the heart of it, I‚Äôm someone who learns best by doing, breaking, and rebuilding. Tech isn‚Äôt just what I study, it‚Äôs something I live and breathe, and I‚Äôm excited to keep exploring where it takes me.\n","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"About","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]